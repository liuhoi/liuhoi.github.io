{"meta":{"title":"刘辉的博客","subtitle":"付出努力才会得到回报","description":"刘辉的博客","author":"刘辉","url":"https://liuhoi.github.io"},"pages":[{"title":"404","date":"2017-10-22T03:03:26.000Z","updated":"2018-04-09T14:20:55.878Z","comments":true,"path":"404/index.html","permalink":"https://liuhoi.github.io/404/index.html","excerpt":"","text":""},{"title":"about","date":"2017-10-21T12:34:31.000Z","updated":"2018-04-09T14:20:55.893Z","comments":true,"path":"about/index.html","permalink":"https://liuhoi.github.io/about/index.html","excerpt":"","text":""},{"title":"归档","date":"2017-10-22T03:21:43.000Z","updated":"2018-04-09T14:20:55.906Z","comments":true,"path":"archives/index.html","permalink":"https://liuhoi.github.io/archives/index.html","excerpt":"","text":""},{"title":"分类","date":"2017-10-22T02:54:39.000Z","updated":"2018-04-09T14:20:55.920Z","comments":false,"path":"categories/index.html","permalink":"https://liuhoi.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2017-10-22T02:54:24.000Z","updated":"2018-04-09T14:20:55.934Z","comments":false,"path":"tags/index.html","permalink":"https://liuhoi.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"vue项目搭建","slug":"vue项目搭建","date":"2018-04-12T12:17:46.000Z","updated":"2018-04-12T12:50:32.163Z","comments":true,"path":"2018/04/12/vue项目搭建/","link":"","permalink":"https://liuhoi.github.io/2018/04/12/vue项目搭建/","excerpt":"","text":"第一部分：vue项目的搭建vue项目的搭建全局安装 vue-cli $ npm install --global vue-cli 创建一个基于 webpack 模板的新项目 $ vue init webpack my-project 安装依赖，走你 123$ cd my-project$ npm install$ npm run dev 第二部分:插件1. Sass的引进1. npm命令12$ npm install node-sass -–save-dev$ npm install sass-loader –-save-dev 2. 配置webpack.base.conf.js12345678910module.exports=&#123; module:&#123; rules:[ &#123; test: /\\.scss$/, loaders: [&quot;style&quot;, &quot;css&quot;, &quot;sass&quot;] &#125;, ] &#125;&#125; 3. Xxx.vue中使用1&lt;style lang=&quot;scss&quot; scoped type=&quot;text/css&quot;&gt;&lt;/style&gt; 2. jquery的引进1. npm命令$ npm install –-save jquery 2. 配置webpack.base.conf.js在开头引入webpack，后面的plugins那里需要 var webpack = require(&#39;webpack&#39;)1234567891011121314151617181920module.exports = &#123; // 其他代码... resolve: &#123; extensions: [&apos;.js&apos;, &apos;.vue&apos;, &apos;.json&apos;], alias: &#123; &apos;vue$&apos;: &apos;vue/dist/vue.esm.js&apos;, &apos;@&apos;: resolve(&apos;src&apos;), &apos;jquery&apos;: &apos;jquery&apos; &#125; &#125;, // 增加一个plugins plugins: [ new webpack.ProvidePlugin(&#123; $: &quot;jquery&quot;, jQuery: &quot;jquery&quot; &#125;) ], // 其他代码...&#125; 3. layui的引进(不建议使用)直接script,link方式引用 123&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;static/lib/layui/css/layui.css&quot;/&gt;&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;static/lib/swiper-2.7.6/idangerous.swiper.css&quot;&gt;&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;static/lib/swiper-2.7.6/idangerous.swiper.scrollbar.css&quot;&gt; 123&lt;script src=&quot;static/lib/layui/layui.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;static/lib/swiper-2.7.6/idangerous.swiper.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;static/lib/swiper-2.7.6/idangerous.swiper.scrollbar-2.1.js&quot;&gt;&lt;/script&gt; 4. element-ui的引进(建议使用)1. npm命令npm i element-ui --save 2. 配置main.js在main.js中写入一下内容 123import ElementUI from &apos;element-ui&apos;import &apos;element-ui/lib/theme-chalk/index.css&apos;Vue.use(ElementUI) 5. axios的引进(ie9不支持需引入polyfill)暂时采用挂载在Vue原型上面 1. npm命令12$ npm install -–save axios$ npm install es6-promise --save-dev 2. 在ajax.js1234567891011121314151617181920212223242526272829303132import qs from &apos;qs&apos;import axios from &apos;axios&apos;import promise from &apos;es6-promise&apos;promise.polyfill();//请求地址axios.defaults.baseURL = &apos;http://www.baid.com/&apos;;//请求超时时间。axios.defaults.timeout = 10000;//添加一个请求拦截器axios.interceptors.request.use(function(config)&#123; //在请求发送之前做一些事 config.url = config.url+&apos;.do&apos;; config.headers = &#123; &apos;Content-Type&apos;:&apos;application/x-www-form-urlencoded;charset=utf-8&apos; &#125;; return config;&#125;,function(error)&#123; //当出现请求错误是做一些事 return Promise.reject(error);&#125;);//请求时对数据进行转化。axios.defaults.transformRequest = [function (data, headers) &#123; if(headers[&apos;Content-Type&apos;]===&apos;application/json&apos;)&#123; return data; &#125;else&#123; return qs.stringify(data); &#125;&#125;];export default (axios); 3. 在main.js123import axiosInstance from &apos;@/assets/ajax&apos;Vue.prototype.$axios = axiosInstance; 4. 在xxx.VUE中使用12345678910111213141516171819202122methods:&#123; guideDetailFn:function()&#123;//服务指南详情 this.$axios(&#123; method: &apos;post&apos;, url: &apos;serviceGuide/getServiceGuide&apos;, params: &#123; id:this.$route.params.id, &#125;, &#125;).then(function (response) &#123; &#125;.bind(this)) .catch(function (error) &#123; console.log(error); &#125;); &#125;,&#125;,created:function()&#123; this.$axios.all([this.guideDetailFn()]) .then(this.$axios.spread(function (acct, perms) &#123; // Both requests are now complete &#125;)); &#125;, 6. Es6兼容ie91. npm命令$ npm install babel-polyfill -–save-dev 2. 在webpack.base.conf.js123456module.exports = &#123; entry: &#123; &apos;babel-polyfill&apos;: &apos;babel-polyfill&apos;, app: &apos;./src/main.js&apos; &#125;&#125; 7. Vuex引用1. npm命令$ npm install vuex –-save 2. 在main.js中配置1234567891011121314151617181920import Vue from &apos;vue&apos;import Vuex from &apos;vuex&apos;Vue.use(Vuex)const store = new Vuex.Store(&#123; state: &#123; count: 0 &#125;, mutations: &#123; increment (state) &#123; state.count++ &#125; &#125; &#125;)new Vue(&#123; el: &apos;#app&apos;, router, store, template: &apos;&lt;App/&gt;&apos;, components: &#123; App &#125;&#125;) 8. Vue-lazyload引用1. npm命令$ npm install vue-lazyload --save 2. 在main.js中配置12345678import VueLazyload from &apos;vue-lazyload&apos;Vue.use(VueLazyload, &#123; preLoad: 1.3, error: &apos;dist/error.png&apos;, loading: &apos;dist/loading.gif&apos;, attempt: 1&#125;) 9. 图片路径问题1. 在config文件夹中index.js中配置123456789101112131415161718192021222324252627282930313233343536373839build: &#123; env: require(&apos;./prod.env&apos;), index: path.resolve(__dirname, &apos;../dist/index.html&apos;), assetsRoot: path.resolve(__dirname, &apos;../dist&apos;), assetsSubDirectory: &apos;static&apos;, assetsPublicPath: &apos;/&apos;, productionSourceMap: true, // Gzip off by default as many popular static hosts such as // Surge or Netlify already gzip all static assets for you. // Before setting to `true`, make sure to: // npm install --save-dev compression-webpack-plugin productionGzip: false, productionGzipExtensions: [&apos;js&apos;, &apos;css&apos;], // Run the build command with an extra argument to // View the bundle analyzer report after build finishes: // `npm run build --report` // Set to `true` or `false` to always turn it on or off bundleAnalyzerReport: process.env.npm_config_report &#125;,改为build: &#123; env: require(&apos;./prod.env&apos;), index: path.resolve(__dirname, &apos;../dist/index.html&apos;), assetsRoot: path.resolve(__dirname, &apos;../dist&apos;), assetsSubDirectory: &apos;static&apos;, assetsPublicPath: &apos;./&apos;, productionSourceMap: true, // Gzip off by default as many popular static hosts such as // Surge or Netlify already gzip all static assets for you. // Before setting to `true`, make sure to: // npm install --save-dev compression-webpack-plugin productionGzip: false, productionGzipExtensions: [&apos;js&apos;, &apos;css&apos;], // Run the build command with an extra argument to // View the bundle analyzer report after build finishes: // `npm run build --report` // Set to `true` or `false` to always turn it on or off bundleAnalyzerReport: process.env.npm_config_report &#125;, 2. 在build文件夹中utils.js中配置123456789101112131415161718if (options.extract) &#123; return ExtractTextPlugin.extract(&#123; use: loaders, fallback: &apos;vue-style-loader&apos; &#125;) &#125; else &#123; return [&apos;vue-style-loader&apos;].concat(loaders) &#125;改为if (options.extract) &#123; return ExtractTextPlugin.extract(&#123; use: loaders, publicPath:&apos;../../&apos;, fallback: &apos;vue-style-loader&apos; &#125;)&#125; else &#123; return [&apos;vue-style-loader&apos;].concat(loaders)&#125; 10. 路径只是参数变化如果目的地和当前路由相同，只有参数发生了改变 (比如从一个用户资料到另一个 /users/1 -&gt; /users/2)，使用 beforeRouteUpdate 来响应这个变化 1. 在xxx.VUE中使用123456789beforeRouteUpdate:function(to, from, next) &#123; next(); this.axjax();//查询请求&#125;,methods:&#123; nextDetail:function()&#123; this.$router.push(&#123;name:this.$route.name,params:&#123;id:this.detailNext.id&#125;&#125;) &#125;&#125; 注意：使用name不使用path使用path会出现错误 11. Chrome浏览器安装vue-devtools（先按照官网的教程安装 如报错在使用下面的方法）123456789101112131415161718192021222324252627下载devtools打开下载好的vue-devtools文件夹打开package.json文件 找到依赖包devDependencies里面的以下三个包进行删除 buble,buble-loader,selenium-server进入文件夹vue-devtools打开命令窗口下载以上删除的包：cnpm install bublecnpm install buble-loadercnpm install wbuf cnpm install selenium-server(该安装过程可能会卡在那里，按ctrl+c结束,不影响) 下载依赖包里的安装包 cnpm install 运行 npm run build进入文件夹vue-devtools 进入shells--&gt;chrome--&gt;manifest.json打开修改以下内容：找到以下部分： &quot;persistent&quot;:false 修改为： &quot;persistent&quot;:true 进入shells--&gt;chrome--&gt;webpack.config.js打开修改以下内容：(按照自己的需求来) 找到以下部分：（最后面） &apos;process.env&apos;:&#123;NODE_ENV:&quot;production&quot;&#125; 修改为： &apos;process.env&apos;:&#123;NODE_ENV:&quot;development&quot;&#125;把插件应用到浏览器找到文件夹vue-devtools\\shells下的chrome文件夹 直接拖进浏览器的更多工具--&gt;扩展程序里 12. 上传到服务器1. npm命令$ npm run build12命令执行后会在当前工程在创建dist文件夹将dist目录放在服务器中就可以了 第三部分:自定义组件1. 倒计时组件1. Html&lt;code&gt;&lt;count-down :time=&quot;info.biddingTime&quot;&gt;&lt;/count-down&gt;&lt;/code&gt; 2. js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354Vue.component:&#123; &apos;count-down&apos;:&#123; template:&apos;&lt;span class=&quot;time&quot;&gt;&#123;&#123;needTime&#125;&#125;&lt;/span&gt;&apos;, data:function()&#123; return&#123; needTime:&apos;&apos; &#125; &#125;, props:[&apos;time&apos;], methods:&#123; dealTime:function(time)&#123; var leftTime = time; var days = parseInt(leftTime / 1000 / 60 / 60 / 24 , 10); //计算剩余的天数 var hours = parseInt(leftTime / 1000 / 60 / 60 % 24 , 10); //计算剩余的小时 var minutes = parseInt(leftTime / 1000 / 60 % 60, 10);//计算剩余的分钟 var seconds = parseInt(leftTime / 1000 % 60, 10);//计算剩余的秒数 days = checkTime(days); hours = checkTime(hours); minutes = checkTime(minutes); seconds = checkTime(seconds); function checkTime(i)&#123; //将0-9的数字前面加上0，例1变为01 if(i&lt;10) &#123; i = &quot;0&quot; + i; &#125; return i; &#125; return (hours+&quot;:&quot; + minutes+&quot;:&quot;+seconds); &#125;, getTime:function(time)&#123; var date = time - Date.now(); if(date&lt;=0)&#123; this.needTime = &apos;00:00:00&apos;; &#125;else&#123; this.needTime = this.dealTime(date); var interval = setInterval(function()&#123; date = time - Date.now(); if(date&lt;=0)&#123; clearInterval(interval); this.needTime = &apos;00:00:00&apos;; &#125;else&#123; this.needTime = this.dealTime(date); &#125; &#125;.bind(this),1000) &#125; &#125; &#125;, created:function()&#123; this.needTime = + new Date(this.time.replace(/\\-/g,&apos;/&apos;).replace(/\\.0/g,&apos;&apos;)); this.getTime(this.needTime); &#125; &#125;&#125;","categories":[{"name":"vue","slug":"vue","permalink":"https://liuhoi.github.io/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://liuhoi.github.io/tags/vue/"}]},{"title":"mui+vue结合使用","slug":"mui-vue结合使用","date":"2017-11-15T12:52:40.000Z","updated":"2018-04-09T14:20:16.091Z","comments":true,"path":"2017/11/15/mui-vue结合使用/","link":"","permalink":"https://liuhoi.github.io/2017/11/15/mui-vue结合使用/","excerpt":"","text":"Mui组件通用CSS类名省略 当文字内容超过一行或者多行时，溢出文本用省略号代替。 显示单行：.mui-ellipsis&lt;p class=&quot;mui-ellipsis&quot;&gt;我在一行内，当我超出了会。&lt;/p&gt; 显示两行：.mui-ellipsis-2&lt;p class=&quot;mui-ellipsis-2&quot;&gt;我在一行内，当我超出了会。&lt;/p&gt; 若需要设置显示多行，通过设置-webkit-line-clamp属性，如显示三行添加style=”-webkit-line-clamp:3”:&lt;p class=&quot;mui-ellipsis-2&quot; style=&quot;-webkit-line-clamp:3&quot;&gt;我在三行内，当我超出了会显示省略号。我在三行内，当我超出了会显示省略号。我在三行内，当我超出了会显示省略号。我在三行内，当我超出了会显示省略号。我在三行内，当我超出了会显示省略号。我在三行内，当我超出了会显示省略号。&lt;/p&gt; 布局 整体结构如下： 12345678910&lt;header class=&quot;mui-bar mui-bar-nav&quot;&gt; &lt;a class=&quot;mui-action-back mui-icon mui-icon-left-nav mui-pull-left&quot;&gt;&lt;/a&gt; &lt;h1 class=&quot;mui-title&quot;&gt;标题&lt;/h1&gt;&lt;/header&gt;&lt;footer class=&quot;mui-bar mui-bar-footer&quot;&gt; 底部&lt;/footer&gt;&lt;div class=&quot;mui-content&quot;&gt; 主体&lt;/div&gt; 当底部内容为选项卡时候，我们会将.mui-bar-footer替换为.mui-bar-tab： 123456789101112131415161718&lt;nav class=&quot;mui-bar mui-bar-tab&quot;&gt; &lt;a class=&quot;mui-tab-item mui-active&quot;&gt; &lt;span class=&quot;mui-icon mui-icon-home&quot;&gt;&lt;/span&gt; &lt;span class=&quot;mui-tab-label&quot;&gt;首页&lt;/span&gt; &lt;/a&gt; &lt;a class=&quot;mui-tab-item&quot;&gt; &lt;span class=&quot;mui-icon mui-icon-phone&quot;&gt;&lt;/span&gt; &lt;span class=&quot;mui-tab-label&quot;&gt;电话&lt;/span&gt; &lt;/a&gt; &lt;a class=&quot;mui-tab-item&quot;&gt; &lt;span class=&quot;mui-icon mui-icon-email&quot;&gt;&lt;/span&gt; &lt;span class=&quot;mui-tab-label&quot;&gt;邮件&lt;/span&gt; &lt;/a&gt; &lt;a class=&quot;mui-tab-item&quot;&gt; &lt;span class=&quot;mui-icon mui-icon-gear&quot;&gt;&lt;/span&gt; &lt;span class=&quot;mui-tab-label&quot;&gt;设置&lt;/span&gt; &lt;/a&gt;&lt;/nav&gt; 局部元素布局设置边距 (默认为10px外边距)。.mui-content-padded 设置元素为内联块，内联，块对象.mui-inlineblock .mui-inline .mui-block 浮动.mui-clearfix .mui-pull-left .mui-pull-right OS环境判断多平台适配： mui会通过.mui.os.*方法判断环境，将.mui-plus，.mui-plus-stream，.mui-ios，.mui-android，.mui-wechat，.mui-ios-version，.mui-android-version，.mui-wechat-version绑定在document.body.classList中，我们可以通过这些样式类判断当前的运行判断，于是可以做出一些适配，如： 12345678&lt;div class=&quot;mui-input-row mui-plus-visible&quot;&gt; &lt;label&gt;mui-plus-visible&lt;/label&gt; &lt;input type=&quot;text&quot; class=&quot;mui-input-speech mui-input-clear&quot; placeholder=&quot;我在web环境下隐藏5+环境下显示&quot;&gt;&lt;/div&gt;&lt;div class=&quot;mui-input-row mui-plus-hidden&quot;&gt; &lt;label&gt;mui-plus-hidden&lt;/label&gt; &lt;input type=&quot;text&quot; class=&quot;mui-input-clear&quot; placeholder=&quot;我在web环境下显示5+环境下隐藏&quot;&gt;&lt;/div&gt; mui中默认在plus环境下和微信环境下设置了样式几个样式： mui-plus-visible：在plus环境下显示，非plsu环境下隐藏 mui-wechat-visible：在wechat环境下显示，非wechat环境下隐藏 mui-plus-hidden：在plus环境下隐藏，非plsu环境下显示 mui-wechat-hidden：在wechat环境下隐藏，非wechat环境下显示 栅格系统布局.mui-row mui-col-xs-4 mui-col-sm-3 区域滚动布局(需手动设置高度，否者滚动区域没有高度)12345&lt;div class=&quot;mui-scroll-wrapper&quot;&gt; &lt;div class=&quot;mui-scroll&quot;&gt; &lt;!--这里放置真实显示的DOM内容--&gt; &lt;/div&gt;&lt;/div&gt; // 常用配置项 123456789var options = &#123; scrollY: true, //是否竖向滚动 scrollX: false, //是否横向滚动 startX: 0, //初始化时滚动至x startY: 0, //初始化时滚动至y indicators: true, //是否显示滚动条 deceleration:0.0006 //阻尼系数,系数越小滑动越灵敏 bounce: true, //是否启用回弹&#125; eg： 123mui(&apos;.mui-scroll-wrapper&apos;).scroll(&#123; deceleration: 0.0005 //flick 减速系数，系数越大，滚动速度越慢，滚动距离越小，默认值0.0006&#125;); 手动设置高度：一般在scroll控件最外面设置div为绝对定位，设置top,bottom,left,right值，为了方便，mui默认设置有个全屏类.mui-fullscreen。 1234567.mui-fullscreen &#123; position: absolute; top: 0; right: 0; bottom: 0; left: 0;&#125; Mui常用配置mui.openWindow配置（最好是通过URL传参数，使用extras有兼容性问题）1234567891011121314151617181920212223242526mui.openWindow(&#123; url: name + &apos;.html?id=&apos; + id, id: name + &apos;.html?id=&apos; + id, styles: &#123; popGesture: &apos;close&apos;,//苹果返回 &#125;, extras: &#123; //自定义扩展参数，可以用来处理页面间传值,仅仅首次创建有自定义扩展参数 &#125;, createNew: false, //是否重复创建同样id的webview，默认为false:不重复创建，直接显示 show: &#123; autoShow: true, //页面loaded事件发生后自动显示，默认为true aniShow: &apos;slide-in-right&apos;, //页面显示动画，默认为”slide-in-right“； duration: 200, //页面动画持续时间，Android平台默认100毫秒，iOS平台默认200毫秒； event: &apos;titleUpdate&apos;, //页面显示时机，默认为titleUpdate事件时显示 extras: &#123;&#125; //窗口动画是否使用图片加速 &#125;, waiting: &#123; autoShow: true, //自动显示等待框，默认为true title: &apos;加载中&apos;, //等待对话框上显示的提示内容 options: &#123; //width:120,等待框背景区域宽度，默认根据内容自动计算合适宽度 //height:100,等待框背景区域高度，默认根据内容自动计算合适高度 &#125; &#125;&#125;) 单webview上拉加载下拉刷新配置123456789101112131415161718192021mui.init(&#123; swipeBack: false, pullRefresh: &#123; container: &apos;#pullrefresh&apos;, down: &#123; style: &apos;circle&apos;, offset: &apos;44px&apos;, contentdown: &quot;下拉可以刷新&quot;, //可选，在下拉可刷新状态时，下拉刷新控件上显示的标题内容 contentover: &quot;释放立即刷新&quot;, //可选，在释放可刷新状态时，下拉刷新控件上显示的标题内容 contentrefresh: &quot;正在刷新...&quot;, //可选，正在刷新状态时，下拉刷新控件上显示的标题内容 auto: false, callback: function()&#123;&#125; &#125;, up: &#123; auto: false, contentrefresh: &apos;正在加载...&apos;, callback: function()&#123;&#125; &#125; &#125;&#125;); 下拉刷新和上拉加载实现(下拉刷新中有重置上拉加载的方法) 下拉刷新 123456789function() &#123; //下拉刷新具体业务实现 setTimeout(function() &#123; index = 1; alert(&apos; 下拉刷新&apos;); mui(&apos;#pullrefresh&apos;).pullRefresh().refresh(true) mui(&apos;#pullrefresh&apos;).pullRefresh().endPullupToRefresh(false); //参数为true代表没有更多数据了。 mui(&apos;#pullrefresh&apos;).pullRefresh().endPulldownToRefresh(); //refresh completed &#125;, 500);&#125; 上拉加载 123456789function() &#123; //上拉加载具体业务实现 setTimeout(function() &#123; index++ mui(&apos;#pullrefresh&apos;).pullRefresh().endPullupToRefresh(index&gt;pageAll); //参数为true代表没有更多数据了。 if(index&lt;=pageAll)&#123; alert(&apos; 上拉加载&apos;); &#125; &#125;, 500);&#125; Ajax请求1234567891011121314mui.ajax(&#123; url: url,//请求地址 data: data,//请求参数 async: true, dataType: &apos;json&apos;, crossDomain: true, //强制使用5+跨域 type: &apos;post&apos;, timeout: 28000, headers: &#123;&apos;Content-Type&apos;: &apos;application/x-www-form-urlencoded&#125;, beforeSend: function()&#123;&#125;, success: function()&#123;&#125;, error: function(XMLHttpRequest, textStatus, errorThrown) &#123;&#125;, complete: function()&#123;&#125;&#125;); Mui与jq冲突解决办法var $j = jQuery.noConflict(true); Mui传值 传递参数 1234mui.fire(webview, &apos;show&apos;, &#123; id: &apos;id&apos;, //传往对应webview的值 name: &apos;name2&apos; //传往对应webview的值 &#125;); 接受参数 12345window.addEventListener(&apos;show&apos;, function(event) &#123; //获得事件参数 var id = event.detail.id; var name = event.detail.name;&#125;); Div模式下顶部渐变配置12345678910111213&lt;div class=&quot;mui-scroll-wrapper&quot;&gt; &lt;div class=&quot;mui-scroll&quot;&gt; &lt;!--这里放置真实显示的DOM内容--&gt; &lt;/div&gt;&lt;/div&gt;&lt;header class=&quot;mui-bar mui-bar-transparent&quot;&gt; &lt;a class=&quot;mui-action-back mui-icon mui-icon-left-nav mui-pull-left&quot;&gt;&lt;/a&gt; &lt;h1 class=&quot;mui-title&quot;&gt;产品信息&lt;/h1&gt;&lt;/header&gt;&lt;div class=&quot;mui-content&quot;&gt; &lt;!--背景图片--&gt; &lt;img id=&quot;img1&quot; src=&quot;../../img/homePage/detailBg.png&quot;&gt;&lt;/div&gt; 常用配置项顶部渐变参数 123456mui(&apos;.mui-bar-transparent&apos;).transparent(&#123; top: 0, offset: 54, duration: 16, scrollby: document.querySelector(&apos;.mui-scroll-wrapper&apos;) || window&#125;) Mui返回时刷新12var wobj = plus.webview.getWebviewById(opener);wobj.reload(true); Mui中判断是否断网123456if(window.plus &amp;&amp; plus.networkinfo.getCurrentType() === plus.networkinfo.CONNECTION_NONE) &#123; plus.nativeUI.toast(&apos;似乎已断开与互联网的连接&apos;, &#123; verticalAlign: &apos;top&apos; &#125;); return;&#125; mui常用函数封装常用Picker poppicker组件依赖mui.picker.js/.css mui.poppicker.js/.css请务必在mui.js/css后中引用,也可统一引用 压缩版本:mui.picker.min.js备注：可通过 instance.pickers[index] 拿到指定层级的实例，然后通过setSelectedIndex()和setSelectedValue()两个方法,设定指定层级的选中项 12345678910111213141516171819202122var picker = new mui.PopPicker();picker.setData([&#123; value: &quot;first&quot;, text: &quot;第一项&quot;&#125;, &#123; value: &quot;second&quot;, text: &quot;第一项&quot;&#125;, &#123; value: &quot;third&quot;, text: &quot;第三项&quot;&#125;, &#123; value: &quot;fourth&quot;, text: &quot;第四项&quot;&#125;, &#123; value: &quot;fifth&quot;, text: &quot;第五项&quot;&#125;])//picker.pickers[0].setSelectedIndex(4, 2000);picker.pickers[0].setSelectedValue(&apos;fourth&apos;, 2000);picker.show(function(SelectedItem) &#123; picker.dispose();&#125;) 地址选择器 poppicker组件依赖mui.picker.js/.css mui.poppicker.js/.css请务必在mui.js/css后中引用,也可统一引用 压缩版本:mui.picker.min.js 123456789101112131415161718192021222324252627282930var picker = new mui.PopPicker(&#123; layer: 2//设置几级联动&#125;);picker.setData([&#123; value: &apos;110000&apos;, text: &apos;北京市&apos;, children: [&#123; value: &quot;110101&quot;, text: &quot;东城区&quot; &#125;]&#125;, &#123; value: &apos;120000&apos;, text: &apos;天津市&apos;, children: [&#123; value: &quot;120101&quot;, text: &quot;和平区&quot; &#125;, &#123; value: &quot;120102&quot;, text: &quot;河东区&quot; &#125;, &#123; value: &quot;120104&quot;, text: &quot;南开区&quot; &#125; ]&#125;])picker.pickers[0].setSelectedIndex(1);picker.pickers[1].setSelectedIndex(1);picker.show(function(SelectedItem) &#123; picker.dispose()；&#125;) 时间选择器 poppicker组件依赖mui.picker.js/.css mui.poppicker.js/.css请务必在mui.js/css后中引用,也可统一引用 压缩版本:mui.picker.min.js 12345678910111213141516var dtPicker = new mui.DtPicker(); var options = &#123; type: &quot;date&quot;, //设置日历初始视图模式 详情参考mui beginDate: new Date(year, month, day), //设置开始日期 &#125;;dtPicker.show(function (rs) &#123; /* * rs.value 拼合后的 value * rs.text 拼合后的 text * rs.y 年，可以通过 rs.y.vaue 和 rs.y.text 获取值和文本 * rs.m 月，用法同年 * rs.d 日，用法同年 * rs.h 时，用法同年 * rs.i 分（minutes 的第二个字母），用法同年 */&#125;) actionSheet 封装1234567891011121314151617181920function()&#123; var btnArray = [&#123;title:&quot;选取现有的&quot;&#125;]; plus.nativeUI.actionSheet( &#123; title:&quot;选择照片&quot;, cancel:&quot;取消&quot;, buttons:btnArray &#125;, function(e)&#123; var index = e.index; switch (index)&#123; case 0: //取消 function()&#123;&#125; break; case 1: //选择照片 function()&#123;&#125; break; &#125; &#125; );&#125; 选取照片12345678910111213141516171819202122232425262728293031323334function()&#123;//获取图片元素 plus.gallery.pick(function(path) &#123; var ele = document.getElementById(&quot;imgUp&quot;); ele.innerHTML = &apos;&apos;; var img = new Image(); img.src = path; ele.appendChild(img); upload(); &#125;, function() &#123;&#125;, &#123; filter: &quot;image&quot; &#125;);&#125;function upload()&#123;// 上传文件 var files = document.querySelector(&apos;#imgUp&apos;); var wt=plus.nativeUI.showWaiting(); var server = &quot;http://192.168.2.01:3000/xxx/UploadFile&quot;; var task=plus.uploader.createUpload(server,&#123;method:&quot;POST&quot;&#125;,function(t,status)&#123; //上传完成 if(status==200)&#123; var data = &#123;&#125;; data.photo = t.responseText.split(&apos;,&apos;)[0]+t.responseText.split(&apos;,&apos;)[1]; console.log(&quot;上传成功：&quot;+t.responseText); Ajax.then(function(r)&#123;//请求&#125;) wt.close(); //关闭等待提示按钮 &#125;else&#123; console.log(&quot;上传失败：&quot;+status); wt.close();//关闭等待提示按钮 &#125; &#125;); //添加其他参数 task.addData(&quot;name&quot;,&quot;test&quot;); task.addFile(files.src,&#123;key:&quot;dddd&quot;&#125;); task.start(); &#125; Mui问题BUG解决办法IOS端键盘弹出后顶部导航栏乱飞 HTML结构 12345&lt;div class=&quot;mui-scroll-wrapper mui-content&quot;&gt; &lt;div class=&quot;mui-scroll&quot;&gt; &lt;!--这里放置真实显示的DOM内容--&gt; &lt;/div&gt;&lt;/div&gt; JS 123456789mui(&apos;.mui-scroll-wrapper&apos;).scroll(&#123; deceleration: 0.0005 //flick 减速系数，系数越大，滚动速度越慢，滚动距离越小，默认值0.0006&#125;);if(window.plus &amp;&amp; mui.os.ios)&#123; var ws = plus.webview.currentWebview(); ws.setStyle(&#123; softinputMode:&apos;adjustResize&apos; &#125;);&#125; IOS端由BUG1引起的光标错位 修改mui.js如下添加判断 ios端关闭’translate3d 123456_getTranslateStr: function(x, y) &#123; if (this.options.hardwareAccelerated &amp;&amp; mui.os.android) &#123; return &apos;translate3d(&apos; + x + &apos;px,&apos; + y + &apos;px,0px) &apos; + this.translateZ; &#125; return &apos;translate(&apos; + x + &apos;px,&apos; + y + &apos;px) &apos;;&#125; Mui结合vue的方案在vue中使用picker封装(单个picker)（结合BUG1， BUG2方案使用） 备注：需在mui.js中picker取消和蒙版消失处添加setTimeout(function(){a.panel.style.display=”none”},350) 解决键盘弹出后会重新计算webview导致picker出现的问题 HTML结构 &lt;input type=&quot;text&quot; v-picker=&quot;{name:&#39;picker&#39;}&quot; readonly &gt; JS 123456789101112131415161718192021mounted: function() &#123; $j(&apos;.mui-poppicker&apos;).hide();//解决键盘弹出后会重新计算webview导致picker出现的问题&#125;,directives:&#123; picker:function(el, binding)&#123; binding.value.name = new mui.PopPicker(); binding.value.name.setData(binding.value.data); el.addEventListener(&apos;tap&apos;, function(event) &#123; $j(binding.value.name.panel).show(); document.activeElement.blur();//失去焦点 binding.value.name.show(function(selectItems) &#123; $j(el).val(selectItems[0].text); setTimeout(function()&#123; $j(binding.value.name.panel).hide(); &#125;,350) binding.value.name.hide(); /*binding.value.name.dispose();只能选一次*/ &#125;); &#125;, false); &#125;&#125; 在vue中使用picker封装(多个在1的基础上修改)1234567891011121314151617181920212223242526Ajax.then(function(r)&#123; localStorage.relatives_type = JSON.stringify(app.relatives_type) localStorage.edu_status = JSON.stringify(app.edu_status)&#125;) directives:&#123; picker: &#123; bind:function(el, binding)&#123; var data=binding.value.pickerType == 0 ? JSON.parse(localStorage.edu_status): JSON.parse(localStorage.relatives_type); binding.value.name = new mui.PopPicker(); binding.value.name.setData(data); el.addEventListener(&apos;tap&apos;, function(event) &#123; $j(binding.value.name.panel).show(); document.activeElement.blur();//失去焦点 binding.value.name.show(function(selectItems) &#123; $j(el).val(selectItems[0].text); setTimeout(function()&#123; $j(binding.value.name.panel).hide(); &#125;,350) binding.value.name.hide(); /*binding.value.name.dispose();只能选一次*/ &#125;); &#125;, false); &#125; &#125;&#125; 在vue中使用:style:style=&quot;{backgroundImage: &#39;url(&#39;+c.imageUrl+&#39;)&#39;}&quot; 在vue做版本更新本地JS 配置 不能在vue里面创建 只能在外面创建 123456var server=&quot;http://www.xrtxdgs.com/XRT/static/version/version.json&quot;,//获取升级描述文件服务器地址localDir=&quot;update&quot;,localFile=&quot;version.json&quot;,//本地保存升级描述目录和文件名keyUpdate=&quot;updateCheck&quot;,//取消升级键名keyAbort=&quot;updateAbort&quot;,//忽略版本键名checkInterval=604800000,//升级检查间隔，单位为ms,7天为7*24*60*60*1000=604800000, 如果每次启动需要检查设置值为0dir=null; 准备升级操作 创建升级文件保存目录 1234567891011121314151617initUpdate:function ()&#123;// 在流应用模式下不需要检测升级操作 if(navigator.userAgent.indexOf(&apos;StreamApp&apos;)&gt;=0)&#123; return; &#125; // 打开doc根目录 plus.io.requestFileSystem( plus.io.PRIVATE_DOC, function(fs)&#123; fs.root.getDirectory(localDir, &#123;create:true&#125;,function(entry)&#123; dir = entry; app.checkUpdate(); console.log( &quot;当前现在目录 &quot;+entry.name ); &#125;, function(e)&#123; console.log( &quot;准备升级操作，打开update目录失败：&quot;+e.message ); &#125;); &#125;,function(e)&#123; console.log( &quot;准备升级操作，打开doc目录失败：&quot;+e.message ); &#125;);&#125;, 检测程序升级 123456789101112131415161718192021222324252627282930313233343536373839checkUpdate:function() &#123; // 判断升级检测是否过期 /*var lastcheck = plus.storage.getItem(keyUpdate ); if ( lastcheck ) &#123; var dc = parseInt( lastcheck ); var dn = (new Date()).getTime(); if ( dn-dc &lt;checkInterval ) &#123; // 未超过上次升级检测间隔，不需要进行升级检查 return; &#125; // 取消已过期，删除取消标记 plus.storage.removeItem(keyUpdate ); &#125;*/ // 读取本地升级文件 dir.getFile(localFile, &#123;create:false&#125;, function(fentry)&#123; fentry.file( function(file)&#123; var reader = new plus.io.FileReader(); reader.onloadend = function ( e ) &#123; /*fentry.remove();*/ app.getUpdateData(); var data = null; try&#123; data=JSON.parse(e.target.result); &#125;catch(e)&#123; console.log( &quot;读取本地升级文件，数据格式错误！&quot; ); return; &#125; app.checkUpdateData( data ); &#125; reader.readAsText(file); &#125;, function(e)&#123; console.log( &quot;读取本地升级文件，获取文件对象失败：&quot;+e.message ); fentry.remove(); &#125; ); &#125;, function(e)&#123; // 失败表示文件不存在，从服务器获取升级数据 console.log( &quot;本地升级文件不存在,从服务器获取升级数据&quot;); app.getUpdateData(); &#125;);&#125;, 检查升级数据 1234567891011121314151617181920212223242526272829checkUpdateData:function( j )&#123; var curVer=plus.runtime.version; console.log(curVer) inf = j[plus.os.name]; console.log(JSON.stringify(j[plus.os.name])) if ( inf )&#123; var srvVer = inf.version; // 判断是否存在忽略版本号 var vabort = plus.storage.getItem( keyAbort ); if ( vabort &amp;&amp; srvVer==vabort ) &#123; // 忽略此版本 return; &#125; // 判断是否需要升级 if ( this.compareVersion(curVer,srvVer) ) &#123; // 提示用户是否升级 plus.nativeUI.confirm( inf.note, function(i)&#123; if ( 0==i.index ) &#123; plus.runtime.openURL( inf.url ); &#125; else if ( 1==i.index ) &#123; plus.storage.setItem( keyAbort, srvVer ); plus.storage.setItem( keyUpdate, (new Date()).getTime().toString() ); &#125; else &#123; plus.storage.setItem( keyUpdate, (new Date()).getTime().toString() ); &#125; &#125;, inf.title, [&quot;立即更新&quot;,&quot;跳过此版本&quot;,&quot;取 消&quot;] ); &#125; &#125;&#125;, 从服务器获取升级数据 123456789101112131415161718192021222324252627282930getUpdateData:function ()&#123; var xhr = new plus.net.XMLHttpRequest(); xhr.onreadystatechange = function () &#123; switch ( xhr.readyState ) &#123; case 4: if ( xhr.status == 200 ) &#123; // 保存到本地文件中 dir.getFile( localFile, &#123;create:true&#125;, function(fentry)&#123; fentry.createWriter( function(writer)&#123; writer.onerror = function()&#123; console.log( &quot;获取升级数据，保存文件失败！&quot; ); &#125; writer.write( xhr.responseText ); &#125;, function(e)&#123; console.log( &quot;获取升级数据，创建写文件对象失败：&quot;+e.message ); &#125; ); &#125;, function(e)&#123; console.log( &quot;获取升级数据，打开保存文件失败：&quot;+e.message ); &#125;); &#125; else &#123; console.log( &quot;获取升级数据，联网请求失败：&quot;+xhr.status ); &#125; break; default : break; &#125; &#125; xhr.open( &quot;GET&quot;, server ); xhr.send();&#125;, 比较版本大小，如果新版本nv大于旧版本ov则返回true，否则返回false @param {String} ov @param {String} nv @return {Boolean} 1234567891011121314151617181920compareVersion:function ( ov, nv )&#123; if ( !ov || !nv || ov==&quot;&quot; || nv==&quot;&quot; )&#123; return false; &#125; var b=false, ova = ov.split(&quot;.&quot;,4), nva = nv.split(&quot;.&quot;,4); for ( var i=0; i&lt;ova.length&amp;&amp;i&lt;nva.length; i++ ) &#123; var so=ova[i],no=parseInt(so),sn=nva[i],nn=parseInt(sn); if ( nn&gt;no || sn.length&gt;so.length ) &#123; return true; &#125; else if ( nn&lt;no ) &#123; mui.toast(&apos;暂无更新&apos;) return false; &#125; &#125; if ( nva.length&gt;ova.length &amp;&amp; 0==nv.indexOf(ov) ) &#123; return true; &#125;&#125; 服务器上var server = serverUrl +&quot;UpdateBsnLicense&quot;;//json服务器路径 服务器上面的version.json 123456789101112131415&#123; &quot;appid&quot;: &quot;App&quot;, &quot;iOS&quot;: &#123; &quot;version&quot;: &quot;1.0.1&quot;, &quot;title&quot;: &quot;1.0.1版本更新&quot;, &quot;note&quot;: &quot;新增自动升级检测功能\\n新增分享功能演示页面\\n新增推送功能演示页面\\n&quot;, &quot;url&quot;: &quot;itms-apps://itunes.apple.com/cn/app/hello-h5+/id682211190?l=zh&amp;mt=8&quot; &#125;, &quot;Android&quot;: &#123; &quot;version&quot;: &quot;1.0.1&quot;, &quot;title&quot;: &quot;1.0.1版本更新&quot;, &quot;note&quot;: &quot;新增自动升级检测功能\\n新增分享功能演示页面\\n新增推送功能演示页面\\n&quot;, &quot;url&quot;: &quot;http://www.app.com/app/static/version/app.apk&quot; &#125;&#125; 在vue中循环中倒计时 HTML &lt;div v-time-countdown=&quot;{getTime:getTimeCoutDown,time:&#39;2017-10-10&#39;}&quot;&gt;&lt;/div&gt; JS 12345678910111213141516171819202122232425262728293031323334getTimeCoutDown:function(time)&#123; var leftTime = time; if(leftTime&lt;=0)&#123; return (0 + &quot;天&quot; + 0 +&quot;小时&quot; + 0 +&quot;分&quot; + 0 +&quot;秒&quot;); else&#123; var days = parseInt(leftTime / 1000 / 60 / 60 / 24 , 10); //计算剩余的天数 var hours = parseInt(leftTime / 1000 / 60 / 60 % 24 , 10); //计算剩余的小时 var minutes = parseInt(leftTime / 1000 / 60 % 60, 10);//计算剩余的分钟 var seconds = parseInt(leftTime / 1000 % 60, 10);//计算剩余的秒数 days = checkTime(days); hours = checkTime(hours); minutes = checkTime(minutes); seconds = checkTime(seconds); function checkTime(i)&#123; //将0-9的数字前面加上0，例1变为01 if(i&lt;10) &#123; i = &quot;0&quot; + i; &#125; return i; &#125; return (&quot;&lt;b&gt;倒计时：&lt;/b&gt;&lt;span&gt;&quot;+days+&quot;&lt;/span&gt;日&lt;span&gt;&quot;+hours+&quot;&lt;/span&gt;小时&lt;span&gt;&quot;+minutes+&quot;&lt;/span&gt;分&quot;); &#125;&#125;directives:&#123; &apos;time-countdown&apos;:&#123; bind:function(el, binding)&#123; el.innerHTML = binding.value.getTime(new Date(binding.value.time) - new Date()) setInterval(function()&#123; now = new Date(); el.innerHTML = binding.value.getTime(new Date(binding.value.time) - now) ; &#125;,1000); &#125; &#125;&#125; 在vue中使用上传图片 CSS HTML JS 123456789101112131415161718192021222324252627282930313233343536373839new Vue(&#123; el:&apos;#app&apos;, data:&#123; sendInfo:&#123; imgUrl:&apos;&apos; &#125;, nativeUrl:&apos;&apos; &#125;, methods:&#123; upload:function()&#123;//获取图片元素 plus.gallery.pick(function(path) &#123; upload(path); &#125;, function() &#123;&#125;, &#123; filter: &quot;image&quot; &#125;); &#125;, upload:function(path)&#123;// 上传文件 var wt=plus.nativeUI.showWaiting(); var server = &quot;http://192.168.2.01:3000/xxx/UploadFile&quot;; var task=plus.uploader.createUpload(server,&#123;method:&quot;POST&quot;&#125;,function(t,status)&#123; //上传完成 if(status==200)&#123; var data = &#123;&#125;; data.photo = t.responseText.split(&apos;,&apos;)[0]+t.responseText.split(&apos;,&apos;)[1]; console.log(&quot;上传成功：&quot;+t.responseText); Ajax.then(function(r)&#123;//请求&#125;) wt.close(); //关闭等待提示按钮 &#125;else&#123; console.log(&quot;上传失败：&quot;+status); wt.close();//关闭等待提示按钮 &#125; &#125;); //添加其他参数 task.addData(&quot;name&quot;,&quot;test&quot;); task.addFile(files.src,&#123;key:&quot;dddd&quot;&#125;); task.start(); &#125; &#125; &#125;)","categories":[{"name":"mui.js+vue.js开发","slug":"mui-js-vue-js开发","permalink":"https://liuhoi.github.io/categories/mui-js-vue-js开发/"}],"tags":[{"name":"mui","slug":"mui","permalink":"https://liuhoi.github.io/tags/mui/"},{"name":"vue","slug":"vue","permalink":"https://liuhoi.github.io/tags/vue/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://liuhoi.github.io/tags/JavaScript/"}]},{"title":"ios 证书申请和APP上架","slug":"ios-证书申请和APP上架","date":"2017-11-04T13:14:49.000Z","updated":"2018-04-09T14:20:16.031Z","comments":true,"path":"2017/11/04/ios-证书申请和APP上架/","link":"","permalink":"https://liuhoi.github.io/2017/11/04/ios-证书申请和APP上架/","excerpt":"","text":"证书申请第一部分：成员介绍1.Certification(证书) 证书是对电脑开发资格的认证，每个开发者帐号有一套，分为两种： Developer Certification(开发证书)安装在电脑上提供权限：开发人员通过设备进行真机测试。可以生成副本供多台电脑安装； Distribution Certification(发布证书)安装在电脑上提供发布iOS程序的权限：开发人员可以制做测试版和发布版的程序。不可生成副本，仅有配置该证书的电脑才可使用； 2.Provisioning Profile(授权文件) 授权文件是对设备如iPod Touch、iPad、iPhone的授权，文件内记录的是设备的UDID和程序的App Id，即：使被授权的设备可以安装或调试Bundle identifier与授权文件中记录的App Id对应的程序。开发者帐号在创建授权文件时候会选择App Id，（开发者帐号下App Id中添加，单选）和UDID（开发者帐号下Devices中添加最多100个，多选）。授权文件分为两种，对应相应的证书使用： Developer Provisioning Profile(开发授权文件)在装有开发证书或副本的电脑上使用，开发人员选择该授权文件通过电脑将程序安装到授权文件记录的设备中，即可进行真机测试。注意：确保电脑有权限真机调试，即安装了开发证书或副本；在开发工具中程序的Bundle identifier和选中使用的授权文件的App Id要一致；连接调试的设备的UDID在选中的授权文件中有记录。 Distribution Provisioning Profile(发布授权文件)在装有发布证书的电脑上（即配置证书的电脑，只有一台）制做测试版和发布版的程序。发布版就是发布到App Store上的程序文件，开发者帐号创建授权文件时选择store选项，选择App Id，无需选择UDID；测试版就是在发布之前交给测试人员可同步到设备上的程序文件，开发者帐号创建授权文件时选择AdHoc，选择App Id和UDID；只有选中的UDID对应的设备才可能安装上通过该授权文件制做的程序。 3. Keychain(开发密钥) 安装证书成功的情况下证书下都会生成Keychain，上面提到的证书副本（导出证书重新命名）就是通过配置证书的电脑导出Keychain（就是.p12文件）安装到其他机子上，让其他机子得到证书对应的权限。Developer Certification就可以制做副本Keychain分发到其他电脑上安装，使其可以进行真机测试。注意：Distribution Certification只有配置证书的电脑才可使用，因此即使导出导出Keychain安装到其他电脑上，其他电脑也不可能具有证书的权限。 证书申请第二部分：证书申请流程step1:登录（99美元账号）https://developer.apple.com 登录成功后在页面右侧选择“Certificates”： 打开之后可以看到面板： step2:生成CSR文件 打开 -&gt;钥匙串访问 打开右上方钥匙串访问栏-&gt;证书助理-&gt;从证书颁发机构请求证书… 填写一个邮箱地址，选择“存储到磁盘”，点击继续，完成了。 申请成功后的文件： step3:注册 App ID 流程 点c_3图面板中的App IDs 右上角的加号。然后填写App ID的名字： 填写bundle ID: 选择App需要支持的服务，（如：app耍要推送服务，就勾选Push Notifications) 最后会有一个详细的内容列表，对应无误后，提交完成。 step4: 证书申请 选择证书的类型，下面罗列我们iOS开发常用的证书类型 如果是申请推送证书，则会关联一个App ID 上传我们之前建好的CSR文件(详见step2) 恭喜你，到此为止，你完成了证书的申请，简单吧。 setp5:授权文件申请（Provisioning Profile） 选择授权文件类型，下面罗列了iOS常的授权文件类型 选择关联App ID 选择关联的证书 选择授权的设备（通过 UDID），除了企业证书（inHouse）外，只有你添加的设备才能进行调度或测试 给授权文件命一个能和其它授权文件区分的名字 恭喜你，到此为止，授权文件申请完成了，简单吧。在我们iOS开发中，常用的证书相关操作流程就全在上面了。 证书申请第三部分:总结 成功安装测试证书的条件：a).开发者证书+私钥。 b).授权文件。 如果你想通过证书进行真机调试，请选择开发版证书(Development Certificate)，和相应的授权文件(Development Provisioning Profile) 。 如果你想让更多的开发者能进行真机调试，请先对需要真机调试的设备进行授权，然后将开发版证书(Development Certificate)下载到本机安装后导出为带私的.p12的文件，和相应的授权文件(Development Provisioning Profile)交由开发者安装，成功后即可进行真机调试。 如果你想让更多的机子进行真机测试，请先对需要测试的设备进行授权，然后选择生产版证书(Distribution Ad_hoc Certificate)和相应的授权文件(Distribution Ad_hoc Provisioning Profile)打包后分发给要测试的设备即可。 IOS上架1.HBuilder准备 图标（需要一张1024*1024） APP显示用的图标 启动图片（安卓3张，ios13张） 2.HBuilder打包需要的文件 AppID(Bundle ID)，私钥密码(生成p12证书时填写的密码)，Profile文件（描述文件也称授权文件以.mobileprovision结尾），私钥证书（p12证书以.p12结尾） 3.Application Loader （苹果上传.ipa的软件） 开发这账户 登陆账户 App专用密码 前往https://appleid.apple.com 申请 图片23 3.iTunes connect准备(苹果的网站https://itunesconnect.apple.com/login) 图标（需要一张1024*1024） APP显示用的图标 APP宣传页(1-5张，分辨率需要如下) 电话号码，邮箱，公司名称，技术支持网址(URL) 等 电话号码，邮箱等 电话号码要加+86如+8613888888888技术支持网址(URL):pc端官网","categories":[{"name":"ios","slug":"ios","permalink":"https://liuhoi.github.io/categories/ios/"}],"tags":[{"name":"ios","slug":"ios","permalink":"https://liuhoi.github.io/tags/ios/"},{"name":"证书申请","slug":"证书申请","permalink":"https://liuhoi.github.io/tags/证书申请/"},{"name":"APP上架","slug":"APP上架","permalink":"https://liuhoi.github.io/tags/APP上架/"}]},{"title":"android 生成证书","slug":"android-生成证书","date":"2017-11-04T11:52:41.000Z","updated":"2018-04-09T14:20:15.951Z","comments":true,"path":"2017/11/04/android-生成证书/","link":"","permalink":"https://liuhoi.github.io/2017/11/04/android-生成证书/","excerpt":"","text":"Android证书申请打包前的准备关于JDK 安装，以及Java环境的设置123456下载JDK1.6，选择对应的安装路径配置相应的Java A、属性名称：JAVA_HOME 属性值：C:\\Program Files\\Java\\jdk1.6.0_02B、属性名称：PATH 属性值：;%JAVA_HOME%\\bin;%JAVA_HOME%\\jre\\binC、属性名称：CLASSPATH 属性值：.;%JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\lib\\tools.jar(注意要加.表示当前路径，另外，%JAVA_HOME%就是引用前面指定的JAVA_HOME) 关于环境变量是否安装成功的测试 “开始”－&gt;;“运行”，键入“cmd”；键入命令命令，出现画面，说明环境变量配置成功： A、java -version； B、java； C、javac； Android SDK的安装与环境变量配置注意：配置Andriod环境变量前提是要先安装好JAVA环境 1234567下载Android SDK，点击安装，直接默认路径即可！ 下载地址：http://developer.android.com/sdk/index.html默认路径安装后，安装完成，开始配置环境变量。打开计算机属性——高级系统设置——环境变量（如上文）新建一个系统环境变量，变量名：ANDROID_HOME，变量值：D:\\adt-bundle-windows-x86_64-20140702\\sdk（以你安装目录为准,确认里面有tools和add-ons等多个文件夹），点击确认。在用户变量PATH后面加上变量值;%ANDROID_HOME%\\platform-tools;点击确认即可。 在系统变量path中添加;D:\\adt-bundle-windows-x86_64-20140702\\sdk\\toolsAndroid SDK配置完成，接下来验证配置是否成功。点击运行——输入cmd——回车——输入adb——回车，如果出现一堆英文，显示成功，即表示配置成功，在输入Android，启动Android SDK Manager。 新建一个数字证书，即keystore文件简介 正式打包发布Android的apk应用，需要先选择或新建一个数字证书，即keystore文件，生成数字证书的常用方法有两：一是利用eclipse生成，二是在命令行中生成，下面我们来介绍如何在命令行中生成Android的数字证书。 首选需要安装jdk环境（这里默认已安装） 因为Android的数字证书keystore文件的生成是用了Java的数据证书管理工具Keytool。确保配置好Java的环境后，使用Windows快捷键Win+R，调出“命令提示符”窗口，在窗口中输入cmd，打开命令行输入如下命令keytool -genkey -alias android.keystore -keyalg RSA -validity 36500 -keystore android.keystore（这句话的意思是：创建了一个名为android.keystore的别名也为android.keystore的采用RSA加密算法的有效期为100年的证书文件） 注： -genkey 生成文件。 -alias 别名。 -keyalg 加密算法。 -validity 有效期。 -keystore 文件名。 然后填写依次填写密钥库口令、确认口令、姓名与姓氏、组织单位、城市或区域、省/市/自治区、国家/地区代码，最后如果正确的话填“y”，如果错误的话直接“Enter”下去，重新 再填，如下图 图片 注意：密钥库口令一定要记住，以后还会用到。当输入”y”后没有回提示输入“输入&lt;android.keystore&gt;的密钥口令”，如果跟密钥库口令一样就按回车键，否则输入，然后再确认，就生成了数字证书，如下图所示 图片 运行结束会在C:\\Users\\Administrator目录下看到一个android.keystore文件 在命令行中输入keytool -list -keystore “android.keystore”命令，然后输入命令就可以看到证书的相关信息，如下图所示。 图片","categories":[{"name":"android","slug":"android","permalink":"https://liuhoi.github.io/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://liuhoi.github.io/tags/android/"},{"name":"keystore","slug":"keystore","permalink":"https://liuhoi.github.io/tags/keystore/"}]},{"title":"多台电脑上提交和更新github博客","slug":"多台电脑上提交和更新github博客","date":"2017-10-23T12:43:39.000Z","updated":"2018-04-10T14:00:37.742Z","comments":true,"path":"2017/10/23/多台电脑上提交和更新github博客/","link":"","permalink":"https://liuhoi.github.io/2017/10/23/多台电脑上提交和更新github博客/","excerpt":"","text":"第一步：git init 初始化git第二步：git branch 查看当前分支情况git branch //查看当前分支情况 查看分支情况 我现在有2个分支 master和hexo 第三步：git branch 分支名，新建一个自己的分支git branch 分支名 // 新建一个自己的分支 创建新分支 我已经创建了一个hexo分支，所以提示已存在 第四步：git checkout 分支名，切换到新建的分支git checkout 分支名 //切换到新建的分支 第五步：git branch，重新查看一下 查看分支情况 带星号表示当前分支 第六步：git remote add origin github地址git remote add origin git@github.com:liuhoi/liuhoi.github.io.git //连接仓库 第七步：进行add命令执行命令git add –all,将修改保存到缓存区，如果想添加某一个文件，则将后面的–all换成你要提交的文件名即可。git add --all 或者 git add . 第八步：commit提交将增加的文件commit到本地仓库里去，执行命令git commmit -m “注释语句” git commit -m &#39;注释语句&#39;（引号内容可改） 第九步：git push -u origin 分支名,同步到github线上将commit的代码push到远程分支 git push -u origin 分支名 //同步到线上新建分支 以后每次更新都执行这三步add,commit,push 添加gitignore忽略上传的方法：vim .gitignore :wq保存设置 忽略文件目录 123vim .gitignore //想要忽略上传的文件或文件夹 :wq保存设置 查看gitignore文件 可以看到有哪些是被忽略的","categories":[{"name":"blog","slug":"blog","permalink":"https://liuhoi.github.io/categories/blog/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://liuhoi.github.io/tags/hexo/"},{"name":"github","slug":"github","permalink":"https://liuhoi.github.io/tags/github/"},{"name":"git","slug":"git","permalink":"https://liuhoi.github.io/tags/git/"}]},{"title":"hexo+github建立博客","slug":"hexo+github建立博客","date":"2017-10-21T12:21:35.000Z","updated":"2018-04-09T14:20:15.990Z","comments":true,"path":"2017/10/21/hexo+github建立博客/","link":"","permalink":"https://liuhoi.github.io/2017/10/21/hexo+github建立博客/","excerpt":"","text":"nodeJs准备 下载地址12查询node版本： node -v查询npm版本： npm -v github账户准备第一步: Github注册打开 注册地址，在下图的框中，分别输入自己的用户名，邮箱，密码。 注册 第二步: 创建代码库登陆之后，点击页面右上角的加号，选择New repository： 创建仓库1 进入代码库创建页面：在Repository name下填写yourname.github.io，Description (optional)下填写一些简单的描述（不写也没有关系），如图所示： 创建仓库2 注意：比如我的github名称是liuhoi ,这里你就填 liuhoi.github.io,如果你的名字是xiaoming，那你就填 xiaoming.github.io 第三步: Website设置 如下图所示 Website设置1 Website设置2 如果你的配置没有问题，那么大约15分钟之后，yourname.github.io这个网址就可以正常访问了~ 如果yourname.github.io已经可以正常访问了，那么Github一侧的配置已经全部结束了。 hexo 安装在自己认为合适的地方创建一个文件夹，这里我以E：/blog 为例子讲解，首先在E盘目录下创建blog文件夹，并在命令行的窗口进入到该目录 创建文件夹 进入之后 执行下面的命令1234567891011121314查询版本 hexo -versionnpm install hexo-cli -ghexo init blogcd blognpm installnpm install hexo-deployer-git --savenpm install hexo-renderer-less --save(预处理Less文件，如不使用indigo主题，则不执行此命令)npm install hexo-generator-feed --save(用于生成 rss，如不使用indigo主题，则不执行此命令)npm install hexo-generator-json-content --save(用于生成静态站点数据，用作站内搜索的数据源，如不使用indigo主题，则不执行此命令)nnpm install hexo-helper-qrcode --save(用于生成微信分享二维码，如不使用indigo主题，则不执行此命令)npm install hexo-asset-image --savehexo generatehexo server在浏览器中打开http://localhost:4000，你将会看到效果 注意：hexo用本地图片步骤1234把主页配置文件_config.yml 里的post_asset_folder:这个选项设置为true在你的E：/blog/blog目录下执行这样一句话npm install hexo-asset-image --save，这是下载安装一个可以上传本地图片的插件运行hexo new &quot;xxxx&quot;来生成md博文时，/source/_posts文件夹内除了xxxx.md文件还有一个同名的文件夹最后在xxxx.md中想引入图片时，先把图片复制到xxxx这个文件夹中，然后只需要在xxxx.md中按照markdown的格式引入图片：![你想输入的替代文字](xxxx/图片名.jpg)注意： xxxx是这个md文件的名字，也是同名文件夹的名字。只需要有文件夹名字即可，不需要有什么绝对路径。你想引入的图片就只需要放入xxxx这个文件夹内就好了，很像引用相对路径。最后检查一下，hexo g生成页面后，进入public\\2017\\02\\26\\index.html文件中查看相关字段，可以发现，html标签内的语句是&lt;img src=&quot;2017/02/26/xxxx/图片名.jpg&quot;&gt;，而不是&lt;img src=&quot;xxxx/图片名.jpg&gt;。这很重要，关乎你的网页是否可以真正加载你想插入的图片。 git 下载地址查询版本 git --versiongit config --system --listgit config --global --listgit config --local --list 配置Git个人信息（使用gitCMD并且进入E：/blog/blog目录）1、设置Git的user name和email：(如果是第一次的话)12git config --global user.name &quot;liuhui&quot;git config --global user.email &quot;pk3845473@163.com&quot; 2、生成密钥ssh-keygen -t rsa -C &quot;pk3845473@163.com&quot; 配置deploy同样在config.yml文件中，找到deploy，然后按照如下修改： deploy 图中红色箭头地址查看如下图： https地址 ssh地址 配置好之后可以生成新文章： 生成新文章命令 hexo new post &quot;article title&quot;(只能为英文 否者在github中不能生成)这时候在我的 电脑的目录下 E：\\blog\\blog\\source\\ _posts 将会看到 article title.md 文件用MarDown编辑器打开就可以编辑文章了。文章编辑好之后，运行生成、部署命令：12部署到github之前执行命令 hexo clean 部署到github命令 hexo deploy hexo 配置hexo _config.yml配置12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182# Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Site ##页面信息title: 刘辉的博客 ##标题，即浏览器标签栏显示的内容subtitle: 付出努力才会得到回报 ##副标题description: 刘辉的博客 ##描述，简介author: 刘辉 ##作者language: zh-CN ##语言timezone: ##时区# URL## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;url: https://liuhoi.github.io/ ##默认点击后URL地址root: /permalink: :year/:month/:day/:title/permalink_defaults:# Directory ##文件目录，可不改source_dir: sourcepublic_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/codei18n_dir: :langskip_render:# Writing ##静态页面生成属性，可不改new_post_name: :title.md # File name of new postsdefault_layout: posttitlecase: false # Transform title into titlecaseexternal_link: true # Open external links in new tabfilename_case: 0render_drafts: falsepost_asset_folder: truerelative_link: falsefuture: truehighlight: enable: true line_number: true auto_detect: false tab_replace: # Home page setting# path: Root path for your blogs index page. (default = &apos;&apos;)# per_page: Posts displayed per page. (0 = disable pagination)# order_by: Posts order. (Order by date descending by default)index_generator: path: &apos;&apos; per_page: 10 order_by: -date # Category &amp; Tag ##标签，可不改default_category: uncategorizedcategory_map:tag_map:# Date / Time format ##时间格式，可不改## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss# Pagination ##每页显示文章数，按需改## Set per_page to 0 to disable paginationper_page: 10pagination_dir: page# Extensions ##主题设置## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: indigo ##主题设置（themes里面）# Deployment ##git部署关联## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: https://github.com/liuhoi/liuhoi.github.io.git branch: master 主题 _config.yml配置以我现在使用的indigo主题为例。首先将主题库clone到blog目录下的themes目录：git clone git@github.com:yscoder/hexo-theme-indigo.git themes/indigoindigo主题 _config.yml配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147# hexo-theme-indigo# https://github.com/yscoder/hexo-theme-indigo# 添加新菜单项遵循以下规则# menu:# link: fontawesome图标，省略前缀，本主题前缀为 icon-，必须# text: About 菜单显示的文字，如果省略即默认与图标一致，首字母会转大写# url: /about 链接，绝对或相对路径，必须。# target: _blank 是否跳出，省略则在当前页面打开menu: home: text: 主页 url: / archives: text: 归档 url: /archives tags: text: 标签 url: /tags th-list: text: 分类 url: /categories github: url: https://liuhoi.github.io/ target: _blank #weibo: #url: http://www.weibo.com/ysweb #target: _blank #link: #text: 测试 #url: /aboutrss: /atom.xml# 你的头像urlavatar: /img/cat1.JPG# avatar linkavatar_link: /# 头像背景图brand: /img/brand.jpg# faviconfavicon: /img/cat1.JPG# emailemail: pk3845473@163.com# 设置 Android L Chrome 浏览器状态栏颜色color: &apos;#3F51B5&apos;# 页面标题tags_title: 标签archives_title: 归档categories_title: 分类# 文章截断excerpt_render: falseexcerpt_length: 200excerpt_link: 阅读全文...mathjax: falsearchive_yearly: true# 是否显示文章最后更新时间show_last_updated: true# 是否开启分享share: true# 是否开启打赏，关闭 reward: falsereward: title: 谢谢大爷~ wechat: /img/wechat.JPG #微信，关闭设为 false alipay: /img/alipay.JPG #支付宝，关闭设为 false# 是否开启搜索search: true# 是否大屏幕下文章页隐藏导航hideMenu: true# 是否开启toc# toc: falsetoc: list_number: true # 是否显示数字排序# 文章页留言内容，hexo中所有变量及辅助函数等均可调用，具体请查阅 hexo.iopostMessage: 这里可以写作者留言，标签和 hexo 中所有变量及辅助函数等均可调用，示例：&lt;a href=&quot;&lt;%- url_for(page.path).replace(/index\\.html$/, &apos;&apos;) %&gt;&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;%- page.permalink.replace(/index\\.html$/, &apos;&apos;) %&gt;&lt;/a&gt;# 站长统计，如要开启，输入CNZZ站点id，如 cnzz: 1255152447cnzz: false# 百度统计，如要开启，改为你的 keybaidu_tongji: false# 腾讯分析，如要开启，输入站点idtajs: false# googlegoogle_analytics: falsegoogle_site_verification: false# lessless: compress: true paths: - source/css/style.less# 以下评论插件开启一个即可# 是否开启 disqusdisqus_shortname: false# 是否开启友言评论, 填写友言用户iduyan_uid: false# 是否使用 gitment，https://github.com/imsun/gitmentgitment: false# gitment:# owner:# repo:# client_id:# client_secret:# 规范网址# 让搜索引擎重定向你的不同域名、不同子域、同域不同目录的站点到你期望的路径# https://support.google.com/webmasters/answer/139066# 假设配置为 canonical: http://imys.net，那么从搜索引擎中 www.imys.net 进入会重定向到 imys.netcanonical: false# 版权起始年份since_year: 2017# 用户页面中作者相关的描述性文字，如不需要设为 falseabout: 用户页面中作者相关的描述性文字，如不需要设为 false# “不蒜子”访问量统计，详见 http://ibruce.info/2015/04/04/busuanzi/visit_counter: site_uv: 站点总访客数： site_pv: 站点总访问量：# 动态定义titletitle_change: normal: 刘辉的博客! leave: 付出努力才会得到回报！# 设置为 true 发布后将使用 unpkg cdncdn: true# 设置为 true 将使用 lightbox render 图片lightbox: true# icp备案号 ICP_license: 京ICP备1234556号-1ICP_license: false 最后生成部署，来看看效果吧12hexo cleanhexo d","categories":[{"name":"blog","slug":"blog","permalink":"https://liuhoi.github.io/categories/blog/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://liuhoi.github.io/tags/hexo/"},{"name":"github","slug":"github","permalink":"https://liuhoi.github.io/tags/github/"},{"name":"git","slug":"git","permalink":"https://liuhoi.github.io/tags/git/"},{"name":"indigo","slug":"indigo","permalink":"https://liuhoi.github.io/tags/indigo/"}]}]}